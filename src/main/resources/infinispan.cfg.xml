<?xml version="1.0" encoding="UTF-8"?>
<infinispan xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="urn:infinispan:config:5.1 http://www.infinispan.org/schemas/infinispan-config-5.1.xsd"
	xmlns="urn:infinispan:config:5.1">

	<!-- *************************** -->
	<!-- System-wide global settings -->
	<!-- *************************** -->

	<global>

		<!-- Duplicate domains are allowed so that multiple deployments with default
			configuration of Hibernate Search applications work - if possible it would 
			be better to use JNDI to share the CacheManager across applications -->
		<globalJmxStatistics enabled="true"
			cacheManagerName="HibernateSearch" allowDuplicateDomains="true" />

		<!-- If the transport is omitted, there is no way to create distributed 
			or clustered caches. There is no added cost to defining a transport but not 
			creating a cache that uses one, since the transport is created and initialized 
			lazily. -->
		<transport clusterName="HibernateSearch-Infinispan-cluster"
			distributedSyncTimeout="50000">
			<!-- Note that the JGroups transport uses sensible defaults if no configuration 
				property is defined. See the JGroupsTransport javadocs for more flags -->
		</transport>

		<!-- Used to register JVM shutdown hooks. hookBehavior: DEFAULT, REGISTER, 
			DONT_REGISTER. Hibernate Search takes care to stop the CacheManager so registering 
			is not needed -->
		<shutdown hookBehavior="DONT_REGISTER" />

	</global>

	<!-- *************************** -->
	<!-- Default "template" settings -->
	<!-- *************************** -->

	<default>

		<locking isolationLevel="REPEATABLE_READ" lockAcquisitionTimeout="20000" writeSkewCheck="false"
			concurrencyLevel="500" useLockStriping="false" />

		<!-- Invocation batching is required for use with the Lucene Directory -->
		<invocationBatching enabled="true" />

		<!-- This element specifies that the cache is clustered. modes supported: 
			distribution (d), replication (r) or invalidation (i). Don't use invalidation 
			to store Lucene indexes (as with Hibernate Search DirectoryProvider). Replication 
			is recommended for best performance of Lucene indexes, but make sure you 
			have enough memory to store the index in your heap. Also distribution scales 
			much better than replication on high number of nodes in the cluster. -->
		<clustering mode="replication">

			<!-- Prefer loading all data at startup than later -->
			<stateRetrieval timeout="20000" logFlushTimeout="30000"
				fetchInMemoryState="true" alwaysProvideInMemoryState="true" />

			<!-- Network calls are synchronous by default -->
			<sync replTimeout="20000" />
		</clustering>

		<jmxStatistics enabled="true" />

		<eviction maxEntries="-1" strategy="NONE" />

		<expiration maxIdle="-1" />

        <transaction useSynchronization="true" transactionMode="TRANSACTIONAL"
                     transactionManagerLookupClass="com.lucho.util.BitronixTransactionManagerLookup">
            <recovery enabled="false" />
        </transaction>
        <deadlockDetection enabled="true" spinDuration="1000"/>
	</default>

	<!-- ******************************************************************************* -->
	<!-- Individually configured "named" caches. -->
	<!-- -->
	<!-- While default configuration happens to be fine with similar settings 
		across the -->
	<!-- three caches, they should generally be different in a production environment. -->
	<!-- -->
	<!-- Current settings could easily lead to OutOfMemory exception as a CacheStore -->
	<!-- should be enabled, and maybe distribution is desired. -->
	<!-- ******************************************************************************* -->

    <!-- Default configuration is appropriate for entity/collection caching. -->
    <namedCache name="entity">
        <clustering mode="invalidation">
            <stateRetrieval fetchInMemoryState="false" timeout="20000"/>
            <sync replTimeout="20000"/>
        </clustering>
        <locking isolationLevel="READ_COMMITTED" concurrencyLevel="1000"
                 lockAcquisitionTimeout="15000" useLockStriping="false" />
        <!-- Eviction configuration.  WakeupInterval defines how often the eviction thread runs, in milliseconds.
                   0 means the eviction thread will never run.  A separate executor is used for eviction in each cache. -->
        <eviction wakeUpInterval="5000" maxEntries="10000" strategy="LRU"/>
        <expiration maxIdle="100000"/>
        <lazyDeserialization enabled="true"/>
    </namedCache>

    <!-- Default configuration is appropriate for entity/collection caching. -->
    <namedCache name="entity-repeatable">
        <clustering mode="invalidation">
            <stateRetrieval fetchInMemoryState="false" timeout="20000"/>
            <sync replTimeout="20000"/>
        </clustering>
        <!-- Note: REPEATABLE_READ is only useful if the application evicts/clears entities
                from the Hibernate Session and then expects to repeatably re-read them in
                the same transaction. Otherwise, the Session's internal cache provides a
                repeatable-read semantic. Before choosing this config, carefully read the docs
                and make sure you really need REPEATABLE_READ.
               -->
        <locking isolationLevel="REPEATABLE_READ" concurrencyLevel="1000"
                 lockAcquisitionTimeout="15000" useLockStriping="false"/>
        <!-- Eviction configuration.  WakeupInterval defines how often the eviction thread runs, in milliseconds.
                   0 means the eviction thread will never run.  A separate executor is used for eviction in each cache. -->
        <eviction wakeUpInterval="5000" maxEntries="10000" strategy="LRU"/>
        <expiration maxIdle="100000"/>
        <lazyDeserialization enabled="true"/>
    </namedCache>

    <!-- An alternative configuration for entity/collection caching that uses replication instead of invalidation -->
    <namedCache name="replicated-entity">
        <clustering mode="replication">
            <stateRetrieval fetchInMemoryState="false" timeout="20000"/>
            <sync replTimeout="20000"/>
        </clustering>
        <locking isolationLevel="READ_COMMITTED" concurrencyLevel="1000"
                 lockAcquisitionTimeout="15000" useLockStriping="false"/>
        <!-- Eviction configuration.  WakeupInterval defines how often the eviction thread runs, in milliseconds.
                   0 means the eviction thread will never run.  A separate executor is used for eviction in each cache. -->
        <eviction wakeUpInterval="5000" maxEntries="10000" strategy="LRU"/>
        <expiration maxIdle="100000"/>
        <lazyDeserialization enabled="true"/>
    </namedCache>


    <!-- A config appropriate for query caching. Does not replicate queries. -->
    <namedCache name="local-query">
        <locking isolationLevel="READ_COMMITTED" concurrencyLevel="1000"
                 lockAcquisitionTimeout="15000" useLockStriping="false"/>
        <!--Eviction configuration.  WakeupInterval defines how often the eviction thread runs, in milliseconds.  0 means
                 the eviction thread will never run.  A separate executor is used for eviction in each cache. -->
        <eviction wakeUpInterval="5000" maxEntries="10000" strategy="LRU"/>
        <expiration maxIdle="100000"/>
    </namedCache>

    <!-- A query cache that replicates queries. Replication is asynchronous. -->
    <namedCache name="replicated-query">
        <clustering mode="replication">
            <async/>
        </clustering>
        <locking isolationLevel="READ_COMMITTED" concurrencyLevel="1000"
                 lockAcquisitionTimeout="15000" useLockStriping="false"/>
        <!--Eviction configuration.  WakeupInterval defines how often the eviction thread runs, in milliseconds.  0 means
                 the eviction thread will never run.  A separate executor is used for eviction in each cache. -->
        <eviction wakeUpInterval="5000" maxEntries="10000" strategy="LRU"/>
        <expiration maxIdle="100000"/>
        <!-- State transfer forces all replication calls to be synchronous,
                   so for calls to remain async, use a cluster cache loader instead -->
        <loaders passivation="false" shared="false" preload="false">
            <loader class="org.infinispan.loaders.cluster.ClusterCacheLoader" fetchPersistentState="false"
                    ignoreModifications="false" purgeOnStartup="false">
                <properties>
                    <property name="remoteCallTimeout" value="20000"/>
                </properties>
            </loader>
        </loaders>
    </namedCache>

    <!-- Optimized for timestamp caching. A clustered timestamp cache
            is required if query caching is used, even if the query cache
            itself is configured with CacheMode=LOCAL. -->
    <namedCache name="timestamps">
        <clustering mode="replication">
            <async/>
        </clustering>
        <locking isolationLevel="READ_COMMITTED" concurrencyLevel="1000"
                 lockAcquisitionTimeout="15000" useLockStriping="false"/>
        <lazyDeserialization enabled="true"/>
        <!--  Don't ever evict modification timestamps -->
        <eviction wakeUpInterval="0" strategy="NONE"/>
        <!-- State transfer forces all replication calls to be synchronous,
                   so for calls to remain async, use a cluster cache loader instead -->
        <loaders passivation="false" shared="false" preload="false">
            <loader class="org.infinispan.loaders.cluster.ClusterCacheLoader" fetchPersistentState="false"
                    ignoreModifications="false" purgeOnStartup="false">
                <properties>
                    <property name="remoteCallTimeout" value="20000"/>
                </properties>
            </loader>
        </loaders>
    </namedCache>

	<!-- *************************************** -->
	<!-- Cache to store Lucene's file metadata -->
	<!-- *************************************** -->
	<namedCache name="LuceneIndexesMetadata">
		<clustering mode="replication">
			<stateRetrieval fetchInMemoryState="true"
				logFlushTimeout="30000" />
			<sync replTimeout="25000" />
		</clustering>
		<transaction useSynchronization="true" transactionMode="TRANSACTIONAL"
			transactionManagerLookupClass="com.lucho.util.BitronixTransactionManagerLookup">
			<recovery enabled="false" />
		</transaction>
		<loaders>
			<loader
				class="org.infinispan.loaders.jdbc.stringbased.JdbcStringBasedCacheStore"
				fetchPersistentState="false" ignoreModifications="false"
				purgeOnStartup="false">
				<properties>
					<property name="key2StringMapperClass" value="org.infinispan.lucene.LuceneKey2StringMapper" />
					<property name="stringsTableNamePrefix" value="ISPN_" />
					<property name="idColumnName" value="ID_COLUMN" />
					<property name="dataColumnName" value="DATA_COLUMN" />
					<property name="timestampColumnName" value="TIMESTAMP_COLUMN" />
					<property name="timestampColumnType" value="bigint" />
                    <!--
					<property name="connectionFactoryClass"
						value="org.infinispan.loaders.jdbc.connectionfactory.ManagedConnectionFactory" />
					<property name="datasourceJndiLocation"
						value="comp/DataSource" />
					-->
                    <property name="connectionFactoryClass"
                              value="org.infinispan.loaders.jdbc.connectionfactory.PooledConnectionFactory"/>
                    <property name="connectionUrl" value="jdbc:h2:nioMapped:/Users/luciano/workspace3/springtwitter/h2data"/>
                    <property name="driverClass" value="org.h2.Driver"/>
                    <property name="userName" value="javajava" />
                    <property name="password" value="javajava" />

					<property name="idColumnType" value="varchar(255)" />
					<property name="dataColumnType" value="bytea" />
					<property name="dropTableOnExit" value="false" />
					<property name="createTableOnStart" value="true" />
				</properties>
			</loader>
		</loaders>
	</namedCache>

	<!-- **************************** -->
	<!-- Cache to store Lucene data -->
	<!-- **************************** -->
	<namedCache name="LuceneIndexesData">
		<clustering mode="replication">
			<stateRetrieval fetchInMemoryState="true"
				logFlushTimeout="30000" />
			<sync replTimeout="25000" />
		</clustering>
		<transaction useSynchronization="true" transactionMode="TRANSACTIONAL"
			transactionManagerLookupClass="com.lucho.util.BitronixTransactionManagerLookup">
			<recovery enabled="false" />
		</transaction>
		<loaders>
			<loader
				class="org.infinispan.loaders.jdbc.stringbased.JdbcStringBasedCacheStore"
				fetchPersistentState="false" ignoreModifications="false"
				purgeOnStartup="false">
				<properties>
					<property name="key2StringMapperClass" value="org.infinispan.lucene.LuceneKey2StringMapper" />
					<property name="stringsTableNamePrefix" value="ISPN_" />
					<property name="idColumnName" value="ID_COLUMN" />
					<property name="dataColumnName" value="DATA_COLUMN" />
					<property name="timestampColumnName" value="TIMESTAMP_COLUMN" />
					<property name="timestampColumnType" value="bigint" />
                    <!--
					<property name="connectionFactoryClass"
						value="org.infinispan.loaders.jdbc.connectionfactory.ManagedConnectionFactory" />
					<property name="datasourceJndiLocation"
						value="comp/DataSource" />
					-->
                    <property name="connectionFactoryClass"
                              value="org.infinispan.loaders.jdbc.connectionfactory.PooledConnectionFactory"/>
                    <property name="connectionUrl" value="jdbc:h2:nioMapped:/Users/luciano/workspace3/springtwitter/h2data"/>   <!-- LOCK MODE = 1 means SERIALIZABLE isolation level -->
                    <property name="driverClass" value="org.h2.Driver"/>
                    <property name="userName" value="javajava" />
                    <property name="password" value="javajava" />

                    <property name="idColumnType" value="varchar(255)" />
					<property name="dataColumnType" value="bytea" />
					<property name="dropTableOnExit" value="false" />
					<property name="createTableOnStart" value="true" />
				</properties>
			</loader>
		</loaders>
	</namedCache>

	<!-- ***************************** -->
	<!-- Cache to store Lucene locks -->
	<!-- ***************************** -->
	<namedCache name="LuceneIndexesLocking">
		<clustering mode="replication">
			<stateRetrieval fetchInMemoryState="true"
				logFlushTimeout="30000" />
			<sync replTimeout="25000" />
		</clustering>

		<transaction useSynchronization="true" transactionMode="TRANSACTIONAL"
			transactionManagerLookupClass="com.lucho.util.BitronixTransactionManagerLookup">
			<recovery enabled="false" />
		</transaction>
	</namedCache>

</infinispan>